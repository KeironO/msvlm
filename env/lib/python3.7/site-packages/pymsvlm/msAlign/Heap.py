class Heap:
    def __init__(self, peaks: list):
        self.peaks = peaks

        self._the_vector = []

        for i, spectra in enumerate(self.peaks):
            if len(spectra) <= 0:
                raise Exception("Heap::Heap(): a spectrum contains no peaks")
            self._the_vector.append([i, 0, spectra[0:50]])

    def empty(self):
        return self._the_vector == []

    def size(self) -> int:
        return len(self._the_vector)

    def top(self) -> float:

        if self.empty():
            raise Exception("Heap::popAndFeed(): theVector must be non empty")

        return self._the_vector[0]

    def pop_and_feed(self, peak):

        def _pop_heap():
            front, back = self._heap[0], self._heap[1]

            if front[2] >= back[2]:
                self._heap[0] = back
                self._heap[-1] = front

        def _push_heap():
            front = self._heap[0]

            if front[2] >= back[2]:


        if self.empty():
            raise Exception("Heap::popAndFeed(): theVector must be non empty")

        returned_peak = self._the_vector[0]

        spectra_indx = returned_peak[0]
        peak_indx = returned_peak[1] + 1 # Must point to the next available peak for the same spectra

        _pop_heap()

        spectra = peak[spectra_indx]

        if peak_indx < len(spectra):
            self._heap[self.size() - 1] = [spectra_indx, peak_indx, spectra[peak_indx]]
            # push_heap()

        else:
            # pop back
            self._heap = self._heap[:-1]

        return returned_peak


    def __repr__(self):
        return self._heap